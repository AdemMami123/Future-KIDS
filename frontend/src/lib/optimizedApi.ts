'use client';\n\nimport { useMemo, useCallback } from 'react';\n\n// Performance-optimized API utilities\nexport class OptimizedAPIClient {\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n  private pendingRequests = new Map<string, Promise<any>>();\n  private defaultTTL = 5 * 60 * 1000; // 5 minutes\n\n  constructor(private baseURL: string) {}\n\n  // Cached fetch with deduplication\n  async fetch<T>(endpoint: string, options?: RequestInit, ttl?: number): Promise<T> {\n    const cacheKey = `${endpoint}_${JSON.stringify(options || {})}`;\n    \n    // Check cache first\n    const cached = this.cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < cached.ttl) {\n      return cached.data;\n    }\n\n    // Check if request is already pending\n    const pendingRequest = this.pendingRequests.get(cacheKey);\n    if (pendingRequest) {\n      return pendingRequest;\n    }\n\n    // Make new request\n    const requestPromise = this.makeRequest<T>(endpoint, options)\n      .then(data => {\n        // Cache successful response\n        this.cache.set(cacheKey, {\n          data,\n          timestamp: Date.now(),\n          ttl: ttl || this.defaultTTL\n        });\n        return data;\n      })\n      .finally(() => {\n        // Remove from pending requests\n        this.pendingRequests.delete(cacheKey);\n      });\n\n    this.pendingRequests.set(cacheKey, requestPromise);\n    return requestPromise;\n  }\n\n  private async makeRequest<T>(endpoint: string, options?: RequestInit): Promise<T> {\n    const response = await fetch(`${this.baseURL}${endpoint}`, {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options?.headers,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`API Error: ${response.status} ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n\n  // Batch multiple requests\n  async batchFetch<T>(requests: { endpoint: string; options?: RequestInit }[]): Promise<T[]> {\n    return Promise.all(\n      requests.map(({ endpoint, options }) => this.fetch<T>(endpoint, options))\n    );\n  }\n\n  // Prefetch data for better perceived performance\n  prefetch(endpoint: string, options?: RequestInit): void {\n    this.fetch(endpoint, options).catch(() => {\n      // Silently fail for prefetch\n    });\n  }\n\n  // Clear cache for specific endpoint or all\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    for (const key of this.cache.keys()) {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  // Get cache statistics\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      pendingRequests: this.pendingRequests.size,\n    };\n  }\n}\n\n// Optimized data fetching hook\nexport function useOptimizedData<T>(\n  fetchFn: () => Promise<T>,\n  deps: React.DependencyList = [],\n  options?: {\n    enabled?: boolean;\n    refetchOnMount?: boolean;\n    staleTime?: number;\n  }\n) {\n  const [data, setData] = React.useState<T | null>(null);\n  const [loading, setLoading] = React.useState(true);\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const memoizedFetch = useCallback(fetchFn, deps);\n\n  React.useEffect(() => {\n    if (options?.enabled === false) return;\n\n    let cancelled = false;\n    setLoading(true);\n    setError(null);\n\n    memoizedFetch()\n      .then(result => {\n        if (!cancelled) {\n          setData(result);\n        }\n      })\n      .catch(err => {\n        if (!cancelled) {\n          setError(err);\n        }\n      })\n      .finally(() => {\n        if (!cancelled) {\n          setLoading(false);\n        }\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [memoizedFetch, options?.enabled]);\n\n  const refetch = useCallback(() => {\n    return memoizedFetch().then(result => {\n      setData(result);\n      return result;\n    });\n  }, [memoizedFetch]);\n\n  return { data, loading, error, refetch };\n}\n\n// Debounced search hook\nexport function useDebouncedSearch<T>(\n  searchFn: (query: string) => Promise<T[]>,\n  delay: number = 300\n) {\n  const [query, setQuery] = React.useState('');\n  const [results, setResults] = React.useState<T[]>([]);\n  const [loading, setLoading] = React.useState(false);\n\n  const debouncedQuery = useMemo(() => {\n    const handler = setTimeout(() => {\n      if (query.trim()) {\n        setLoading(true);\n        searchFn(query)\n          .then(setResults)\n          .catch(() => setResults([]))\n          .finally(() => setLoading(false));\n      } else {\n        setResults([]);\n      }\n    }, delay);\n\n    return () => clearTimeout(handler);\n  }, [query, delay, searchFn]);\n\n  React.useEffect(() => {\n    return debouncedQuery;\n  }, [debouncedQuery]);\n\n  return { query, setQuery, results, loading };\n}\n\n// Intersection observer for infinite scroll\nexport function useInfiniteScroll<T>(\n  fetchMore: (page: number) => Promise<T[]>,\n  options?: {\n    threshold?: number;\n    rootMargin?: string;\n  }\n) {\n  const [items, setItems] = React.useState<T[]>([]);\n  const [loading, setLoading] = React.useState(false);\n  const [hasMore, setHasMore] = React.useState(true);\n  const [page, setPage] = React.useState(1);\n  const observerRef = React.useRef<HTMLDivElement>(null);\n\n  const loadMore = useCallback(async () => {\n    if (loading || !hasMore) return;\n\n    setLoading(true);\n    try {\n      const newItems = await fetchMore(page);\n      if (newItems.length === 0) {\n        setHasMore(false);\n      } else {\n        setItems(prev => [...prev, ...newItems]);\n        setPage(prev => prev + 1);\n      }\n    } catch (error) {\n      console.error('Error loading more items:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchMore, page, loading, hasMore]);\n\n  React.useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          loadMore();\n        }\n      },\n      {\n        threshold: options?.threshold || 0.1,\n        rootMargin: options?.rootMargin || '100px',\n      }\n    );\n\n    const element = observerRef.current;\n    if (element) {\n      observer.observe(element);\n    }\n\n    return () => {\n      if (element) {\n        observer.unobserve(element);\n      }\n    };\n  }, [loadMore, options]);\n\n  return { items, loading, hasMore, observerRef };\n}\n\n// Local storage with expiration\nexport class OptimizedStorage {\n  static set(key: string, value: any, ttlMs?: number) {\n    const item = {\n      value,\n      timestamp: Date.now(),\n      ttl: ttlMs,\n    };\n    localStorage.setItem(key, JSON.stringify(item));\n  }\n\n  static get<T>(key: string): T | null {\n    try {\n      const item = localStorage.getItem(key);\n      if (!item) return null;\n\n      const parsed = JSON.parse(item);\n      if (parsed.ttl && Date.now() - parsed.timestamp > parsed.ttl) {\n        localStorage.removeItem(key);\n        return null;\n      }\n\n      return parsed.value;\n    } catch {\n      return null;\n    }\n  }\n\n  static remove(key: string) {\n    localStorage.removeItem(key);\n  }\n\n  static clear() {\n    localStorage.clear();\n  }\n}