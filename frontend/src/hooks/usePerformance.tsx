'use client';\n\nimport { useEffect, useState } from 'react';\n\n// Performance monitoring utilities\nexport interface PerformanceMetrics {\n  fps: number;\n  memoryUsage?: number;\n  loadTime: number;\n  renderTime: number;\n}\n\nexport function usePerformanceMonitor() {\n  const [metrics, setMetrics] = useState<PerformanceMetrics>({ \n    fps: 60, \n    loadTime: 0,\n    renderTime: 0 \n  });\n\n  useEffect(() => {\n    // Track FPS\n    let frameCount = 0;\n    let lastTime = performance.now();\n    let animationFrameId: number;\n\n    const trackFPS = () => {\n      frameCount++;\n      const currentTime = performance.now();\n      \n      if (currentTime - lastTime >= 1000) {\n        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));\n        setMetrics(prev => ({ ...prev, fps }));\n        frameCount = 0;\n        lastTime = currentTime;\n      }\n      \n      animationFrameId = requestAnimationFrame(trackFPS);\n    };\n\n    // Track initial load time\n    const loadTime = performance.now();\n    setMetrics(prev => ({ ...prev, loadTime }));\n\n    // Track memory usage (if available)\n    if ('memory' in performance) {\n      const memoryInfo = (performance as any).memory;\n      setMetrics(prev => ({\n        ...prev,\n        memoryUsage: memoryInfo.usedJSHeapSize / 1048576 // MB\n      }));\n    }\n\n    trackFPS();\n\n    return () => {\n      if (animationFrameId) {\n        cancelAnimationFrame(animationFrameId);\n      }\n    };\n  }, []);\n\n  return metrics;\n}\n\n// Performance optimization hooks\nexport function useOptimizedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  deps: React.DependencyList,\n  delay: number = 0\n): T {\n  const [debouncedCallback, setDebouncedCallback] = useState(() => callback);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedCallback(() => callback);\n    }, delay);\n\n    return () => clearTimeout(handler);\n  }, [callback, delay, ...deps]);\n\n  return debouncedCallback;\n}\n\n// Debounced state hook for expensive operations\nexport function useDebouncedState<T>(initialValue: T, delay: number = 300) {\n  const [value, setValue] = useState(initialValue);\n  const [debouncedValue, setDebouncedValue] = useState(initialValue);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => clearTimeout(handler);\n  }, [value, delay]);\n\n  return [debouncedValue, setValue] as const;\n}\n\n// Virtual scrolling hook for large lists\nexport function useVirtualScroll({\n  items,\n  itemHeight,\n  containerHeight,\n  overscan = 5,\n}: {\n  items: any[];\n  itemHeight: number;\n  containerHeight: number;\n  overscan?: number;\n}) {\n  const [scrollTop, setScrollTop] = useState(0);\n\n  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);\n  const endIndex = Math.min(\n    items.length - 1,\n    Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan\n  );\n\n  const visibleItems = items.slice(startIndex, endIndex + 1);\n  const totalHeight = items.length * itemHeight;\n  const offsetY = startIndex * itemHeight;\n\n  return {\n    visibleItems,\n    totalHeight,\n    offsetY,\n    startIndex,\n    endIndex,\n    onScroll: (e: React.UIEvent<HTMLDivElement>) => {\n      setScrollTop(e.currentTarget.scrollTop);\n    },\n  };\n}\n\n// Optimized image loading hook\nexport function useOptimizedImages() {\n  useEffect(() => {\n    // Preload critical images\n    const preloadImage = (src: string) => {\n      const link = document.createElement('link');\n      link.rel = 'preload';\n      link.as = 'image';\n      link.href = src;\n      document.head.appendChild(link);\n    };\n\n    // Add your critical images here\n    const criticalImages = [\n      // '/images/logo.png',\n      // '/images/hero-bg.jpg',\n    ];\n\n    criticalImages.forEach(preloadImage);\n  }, []);\n}\n\n// Bundle size monitoring\nexport function useBundleAnalytics() {\n  useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      // Log bundle information in development\n      console.log('Bundle Analytics:', {\n        userAgent: navigator.userAgent,\n        connection: (navigator as any).connection?.effectiveType,\n        memory: (performance as any).memory?.usedJSHeapSize,\n        timing: performance.getEntriesByType('navigation')[0],\n      });\n    }\n  }, []);\n}\n\n// Error boundary for performance issues\nimport React from 'react';\n\ninterface PerformanceErrorBoundaryState {\n  hasError: boolean;\n  errorInfo?: string;\n}\n\nexport class PerformanceErrorBoundary extends React.Component<\n  { children: React.ReactNode; fallback?: React.ReactNode },\n  PerformanceErrorBoundaryState\n> {\n  constructor(props: { children: React.ReactNode; fallback?: React.ReactNode }) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): PerformanceErrorBoundaryState {\n    return {\n      hasError: true,\n      errorInfo: error.message,\n    };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Performance Error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        this.props.fallback || (\n          <div className=\"p-4 border border-red-200 rounded-lg bg-red-50\">\n            <h2 className=\"text-lg font-semibold text-red-800\">Something went wrong</h2>\n            <p className=\"text-red-600 mt-2\">Please try refreshing the page.</p>\n          </div>\n        )\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Performance measurement utility\nexport function measurePerformance<T>(\n  name: string,\n  fn: () => T\n): T {\n  const startTime = performance.now();\n  const result = fn();\n  const endTime = performance.now();\n  \n  console.log(`Performance: ${name} took ${endTime - startTime} milliseconds`);\n  \n  return result;\n}\n\n// Resource hints for better loading\nexport function useResourceHints() {\n  useEffect(() => {\n    // Add DNS prefetch for external domains\n    const prefetchDomains = [\n      'https://fonts.googleapis.com',\n      'https://res.cloudinary.com',\n    ];\n\n    prefetchDomains.forEach(domain => {\n      const link = document.createElement('link');\n      link.rel = 'dns-prefetch';\n      link.href = domain;\n      document.head.appendChild(link);\n    });\n  }, []);\n}