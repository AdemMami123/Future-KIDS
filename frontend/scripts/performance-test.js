#!/usr/bin/env node\n\n/**\n * Simple performance testing script for the frontend\n * Measures bundle sizes, load times, and identifies performance bottlenecks\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\n// ANSI color codes for console output\nconst colors = {\n  reset: '\\x1b[0m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n};\n\nfunction log(color, message) {\n  console.log(`${colors[color]}${message}${colors.reset}`);\n}\n\nfunction formatSize(bytes) {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n  if (bytes === 0) return '0 Bytes';\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + ' ' + sizes[i];\n}\n\nfunction analyzeBundleSize() {\n  log('cyan', '\\nðŸ“¦ Analyzing bundle sizes...');\n  \n  const nextDir = path.join(__dirname, '../.next');\n  const staticDir = path.join(nextDir, 'static');\n  \n  if (!fs.existsSync(nextDir)) {\n    log('red', 'âŒ .next directory not found. Run \"npm run build\" first.');\n    return;\n  }\n  \n  let totalSize = 0;\n  let fileCount = 0;\n  const warnings = [];\n  \n  function analyzeDir(dirPath, relativePath = '') {\n    const items = fs.readdirSync(dirPath);\n    \n    items.forEach(item => {\n      const fullPath = path.join(dirPath, item);\n      const stat = fs.statSync(fullPath);\n      \n      if (stat.isDirectory()) {\n        analyzeDir(fullPath, path.join(relativePath, item));\n      } else {\n        const size = stat.size;\n        totalSize += size;\n        fileCount++;\n        \n        // Check for large files\n        const sizeInKB = size / 1024;\n        if (sizeInKB > 500) { // Files larger than 500KB\n          warnings.push({\n            type: 'large-file',\n            path: path.join(relativePath, item),\n            size: formatSize(size),\n            message: 'Large bundle file detected'\n          });\n        }\n      }\n    });\n  }\n  \n  try {\n    analyzeDir(staticDir, 'static');\n    \n    log('green', `âœ… Total bundle size: ${formatSize(totalSize)}`);\n    log('blue', `ðŸ“„ Total files: ${fileCount}`);\n    \n    // Performance recommendations\n    const sizeInMB = totalSize / (1024 * 1024);\n    if (sizeInMB > 5) {\n      warnings.push({\n        type: 'bundle-size',\n        message: 'Large total bundle size. Consider code splitting and tree shaking.'\n      });\n    }\n    \n    if (warnings.length > 0) {\n      log('yellow', '\\nâš ï¸  Performance warnings:');\n      warnings.forEach((warning, index) => {\n        console.log(`   ${index + 1}. ${warning.message}`);\n        if (warning.path) {\n          console.log(`      File: ${warning.path} (${warning.size})`);\n        }\n      });\n    }\n    \n  } catch (error) {\n    log('red', `âŒ Error analyzing bundle: ${error.message}`);\n  }\n}\n\nfunction checkImageOptimization() {\n  log('cyan', '\\nðŸ–¼ï¸  Checking image optimization...');\n  \n  const publicDir = path.join(__dirname, '../public');\n  if (!fs.existsSync(publicDir)) {\n    log('yellow', 'âš ï¸  Public directory not found.');\n    return;\n  }\n  \n  let imageCount = 0;\n  let totalImageSize = 0;\n  const unoptimizedImages = [];\n  \n  function checkImages(dirPath, relativePath = '') {\n    const items = fs.readdirSync(dirPath);\n    \n    items.forEach(item => {\n      const fullPath = path.join(dirPath, item);\n      const stat = fs.statSync(fullPath);\n      \n      if (stat.isDirectory()) {\n        checkImages(fullPath, path.join(relativePath, item));\n      } else {\n        const ext = path.extname(item).toLowerCase();\n        if (['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'].includes(ext)) {\n          imageCount++;\n          totalImageSize += stat.size;\n          \n          // Check for large images\n          const sizeInKB = stat.size / 1024;\n          if (sizeInKB > 500) {\n            unoptimizedImages.push({\n              path: path.join(relativePath, item),\n              size: formatSize(stat.size),\n              extension: ext\n            });\n          }\n        }\n      }\n    });\n  }\n  \n  try {\n    checkImages(publicDir);\n    \n    log('green', `âœ… Found ${imageCount} images`);\n    log('blue', `ðŸ“ Total image size: ${formatSize(totalImageSize)}`);\n    \n    if (unoptimizedImages.length > 0) {\n      log('yellow', '\\nâš ï¸  Large images found (consider optimization):');\n      unoptimizedImages.forEach((img, index) => {\n        console.log(`   ${index + 1}. ${img.path} (${img.size})`);\n      });\n    }\n    \n  } catch (error) {\n    log('red', `âŒ Error checking images: ${error.message}`);\n  }\n}\n\nfunction checkDependencies() {\n  log('cyan', '\\nðŸ“š Analyzing dependencies...');\n  \n  const packageJsonPath = path.join(__dirname, '../package.json');\n  if (!fs.existsSync(packageJsonPath)) {\n    log('red', 'âŒ package.json not found.');\n    return;\n  }\n  \n  try {\n    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n    const dependencies = {\n      ...packageJson.dependencies,\n      ...packageJson.devDependencies\n    };\n    \n    const heavyDependencies = [\n      'framer-motion',\n      'chart.js',\n      '@tanstack/react-query',\n      'firebase'\n    ];\n    \n    const foundHeavy = [];\n    Object.keys(dependencies).forEach(dep => {\n      if (heavyDependencies.includes(dep)) {\n        foundHeavy.push(dep);\n      }\n    });\n    \n    log('green', `âœ… Total dependencies: ${Object.keys(dependencies).length}`);\n    \n    if (foundHeavy.length > 0) {\n      log('yellow', '\\nâš ï¸  Heavy dependencies detected (ensure they\\'re optimized):');\n      foundHeavy.forEach((dep, index) => {\n        console.log(`   ${index + 1}. ${dep}`);\n      });\n    }\n    \n  } catch (error) {\n    log('red', `âŒ Error analyzing dependencies: ${error.message}`);\n  }\n}\n\nfunction generateRecommendations() {\n  log('cyan', '\\nðŸ’¡ Performance Recommendations:');\n  \n  const recommendations = [\n    '1. Use Next.js Image component for all images',\n    '2. Implement lazy loading for components below the fold',\n    '3. Use React.memo() for expensive components',\n    '4. Optimize animations to run at 60fps',\n    '5. Minimize bundle size with tree shaking',\n    '6. Use service workers for caching',\n    '7. Implement proper loading states',\n    '8. Use Web Vitals to monitor real-world performance'\n  ];\n  \n  recommendations.forEach(rec => {\n    console.log(`   ${rec}`);\n  });\n}\n\nfunction main() {\n  log('magenta', 'ðŸš€ Frontend Performance Analysis');\n  log('magenta', '=================================');\n  \n  analyzeBundleSize();\n  checkImageOptimization();\n  checkDependencies();\n  generateRecommendations();\n  \n  log('green', '\\nâœ¨ Analysis complete! Check the warnings above for optimization opportunities.');\n}\n\nif (require.main === module) {\n  main();\n}